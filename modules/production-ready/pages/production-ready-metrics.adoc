include::ROOT:partial$attributes.adoc[]
[[production-ready-metrics]]
== Metrics
Spring Boot Actuator provides dependency management and auto-configuration for https://micrometer.io[Micrometer], an application metrics facade that supports numerous monitoring systems, including:

- <<production-ready-metrics-export-appoptics,AppOptics>>
- <<production-ready-metrics-export-atlas,Atlas>>
- <<production-ready-metrics-export-datadog,Datadog>>
- <<production-ready-metrics-export-dynatrace,Dynatrace>>
- <<production-ready-metrics-export-elastic,Elastic>>
- <<production-ready-metrics-export-ganglia,Ganglia>>
- <<production-ready-metrics-export-graphite,Graphite>>
- <<production-ready-metrics-export-humio,Humio>>
- <<production-ready-metrics-export-influx,Influx>>
- <<production-ready-metrics-export-jmx,JMX>>
- <<production-ready-metrics-export-kairos,KairosDB>>
- <<production-ready-metrics-export-newrelic,New Relic>>
- <<production-ready-metrics-export-prometheus,Prometheus>>
- <<production-ready-metrics-export-signalfx,SignalFx>>
- <<production-ready-metrics-export-simple,Simple (in-memory)>>
- <<production-ready-metrics-export-statsd,StatsD>>
- <<production-ready-metrics-export-wavefront,Wavefront>>

TIP: To learn more about Micrometer's capabilities, please refer to its https://micrometer.io/docs[reference documentation], in particular the {micrometer-concepts-docs}[concepts section].



[[production-ready-metrics-getting-started]]
=== Getting started
Spring Boot auto-configures a composite `MeterRegistry` and adds a registry to the composite for each of the supported implementations that it finds on the classpath.
Having a dependency on `micrometer-registry-\{system}` in your runtime classpath is enough for Spring Boot to configure the registry.

Most registries share common features.
For instance, you can disable a particular registry even if the Micrometer registry implementation is on the classpath.
For example, to disable Datadog:

[source,properties,indent=0,configprops]
----
	management.metrics.export.datadog.enabled=false
----

Spring Boot will also add any auto-configured registries to the global static composite registry on the `Metrics` class unless you explicitly tell it not to:

[source,properties,indent=0,configprops]
----
	management.metrics.use-global-registry=false
----

You can register any number of `MeterRegistryCustomizer` beans to further configure the registry, such as applying common tags, before any meters are registered with the registry:

[source,java,indent=0]
----
	@Bean
	MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
		return registry -> registry.config().commonTags("region", "us-east-1");
	}
----

You can apply customizations to particular registry implementations by being more specific about the generic type:

[source,java,indent=0]
----
	@Bean
	MeterRegistryCustomizer<GraphiteMeterRegistry> graphiteMetricsNamingConvention() {
		return registry -> registry.config().namingConvention(MY_CUSTOM_CONVENTION);
	}
----

With that setup in place you can inject `MeterRegistry` in your components and register metrics:

[source,java,indent=0]
----
include::{code-examples}/actuate/metrics/SampleBean.java[tag=example]
----

Spring Boot also <<production-ready-metrics-meter,configures built-in instrumentation>> (i.e. `MeterBinder` implementations) that you can control via configuration or dedicated annotation markers.



[[production-ready-metrics-export]]
=== Supported monitoring systems



[[production-ready-metrics-export-appoptics]]
==== AppOptics
By default, the AppOptics registry pushes metrics to `https://api.appoptics.com/v1/measurements` periodically.
To export metrics to SaaS {micrometer-registry-docs}/appoptics[AppOptics], your API token must be provided:

[source,properties,indent=0,configprops]
----
	management.metrics.export.appoptics.api-token=YOUR_TOKEN
----



[[production-ready-metrics-export-atlas]]
==== Atlas
By default, metrics are exported to {micrometer-registry-docs}/atlas[Atlas] running on your local machine.
The location of the https://github.com/Netflix/atlas[Atlas server] to use can be provided using:

[source,properties,indent=0,configprops]
----
	management.metrics.export.atlas.uri=https://atlas.example.com:7101/api/v1/publish
----



[[production-ready-metrics-export-datadog]]
==== Datadog
Datadog registry pushes metrics to https://www.datadoghq.com[datadoghq] periodically.
To export metrics to {micrometer-registry-docs}/datadog[Datadog], your API key must be provided:

[source,properties,indent=0,configprops]
----
	management.metrics.export.datadog.api-key=YOUR_KEY
----

You can also change the interval at which metrics are sent to Datadog:

[source,properties,indent=0,configprops]
----
	management.metrics.export.datadog.step=30s
----



[[production-ready-metrics-export-dynatrace]]
==== Dynatrace
Dynatrace registry pushes metrics to the configured URI periodically.
To export metrics to {micrometer-registry-docs}/dynatrace[Dynatrace], your API token, device ID, and URI must be provided:

[source,properties,indent=0,configprops]
----
	management.metrics.export.dynatrace.api-token=YOUR_TOKEN
	management.metrics.export.dynatrace.device-id=YOUR_DEVICE_ID
	management.metrics.export.dynatrace.uri=YOUR_URI
----

You can also change the interval at which metrics are sent to Dynatrace:

[source,properties,indent=0,configprops]
----
	management.metrics.export.dynatrace.step=30s
----



[[production-ready-metrics-export-elastic]]
==== Elastic
By default, metrics are exported to {micrometer-registry-docs}/elastic[Elastic] running on your local machine.
The location of the Elastic server to use can be provided using the following property:

[source,properties,indent=0,configprops]
----
	management.metrics.export.elastic.host=https://elastic.example.com:8086
----



[[production-ready-metrics-export-ganglia]]
==== Ganglia
By default, metrics are exported to {micrometer-registry-docs}/ganglia[Ganglia] running on your local machine.
The http://ganglia.sourceforge.net[Ganglia server] host and port to use can be provided using:

[source,properties,indent=0,configprops]
----
	management.metrics.export.ganglia.host=ganglia.example.com
	management.metrics.export.ganglia.port=9649
----



[[production-ready-metrics-export-graphite]]
==== Graphite
By default, metrics are exported to {micrometer-registry-docs}/graphite[Graphite] running on your local machine.
The https://graphiteapp.org[Graphite server] host and port to use can be provided using:

[source,properties,indent=0,configprops]
----
	management.metrics.export.graphite.host=graphite.example.com
	management.metrics.export.graphite.port=9004
----

Micrometer provides a default `HierarchicalNameMapper` that governs how a dimensional meter id is {micrometer-registry-docs}/graphite#_hierarchical_name_mapping[mapped to flat hierarchical names].

TIP: To take control over this behaviour, define your `GraphiteMeterRegistry` and supply your own `HierarchicalNameMapper`.
An auto-configured `GraphiteConfig` and `Clock` beans are provided unless you define your own:

[source,java]
----
@Bean
public GraphiteMeterRegistry graphiteMeterRegistry(GraphiteConfig config, Clock clock) {
	return new GraphiteMeterRegistry(config, clock, MY_HIERARCHICAL_MAPPER);
}
----



[[production-ready-metrics-export-humio]]
==== Humio
By default, the Humio registry pushes metrics to https://cloud.humio.com periodically.
To export metrics to SaaS {micrometer-registry-docs}/humio[Humio], your API token must be provided:

[source,properties,indent=0,configprops]
----
	management.metrics.export.humio.api-token=YOUR_TOKEN
----

You should also configure one or more tags to identify the data source to which metrics will be pushed:

[source,properties,indent=0,configprops]
----
	management.metrics.export.humio.tags.alpha=a
	management.metrics.export.humio.tags.bravo=b
----



[[production-ready-metrics-export-influx]]
==== Influx
By default, metrics are exported to {micrometer-registry-docs}/influx[Influx] running on your local machine.
The location of the https://www.influxdata.com[Influx server] to use can be provided using:

[source,properties,indent=0,configprops]
----
	management.metrics.export.influx.uri=https://influx.example.com:8086
----



[[production-ready-metrics-export-jmx]]
==== JMX
Micrometer provides a hierarchical mapping to {micrometer-registry-docs}/jmx[JMX], primarily as a cheap and portable way to view metrics locally.
By default, metrics are exported to the `metrics` JMX domain.
The domain to use can be provided using:

[source,properties,indent=0,configprops]
----
	management.metrics.export.jmx.domain=com.example.app.metrics
----

Micrometer provides a default `HierarchicalNameMapper` that governs how a dimensional meter id is {micrometer-registry-docs}/jmx#_hierarchical_name_mapping[mapped to flat hierarchical names].

TIP: To take control over this behaviour, define your `JmxMeterRegistry` and supply your own `HierarchicalNameMapper`.
An auto-configured `JmxConfig` and `Clock` beans are provided unless you define your own:

[source,java]
----
@Bean
public JmxMeterRegistry jmxMeterRegistry(JmxConfig config, Clock clock) {
	return new JmxMeterRegistry(config, clock, MY_HIERARCHICAL_MAPPER);
}
----



[[production-ready-metrics-export-kairos]]
==== KairosDB
By default, metrics are exported to {micrometer-registry-docs}/kairos[KairosDB] running on your local machine.
The location of the https://kairosdb.github.io/[KairosDB server] to use can be provided using:

[source,properties,indent=0,configprops]
----
	management.metrics.export.kairos.uri=https://kairosdb.example.com:8080/api/v1/datapoints
----



[[production-ready-metrics-export-newrelic]]
==== New Relic
New Relic registry pushes metrics to {micrometer-registry-docs}/new-relic[New Relic] periodically.
To export metrics to https://newrelic.com[New Relic], your API key and account id must be provided:

[source,properties,indent=0,configprops]
----
	management.metrics.export.newrelic.api-key=YOUR_KEY
	management.metrics.export.newrelic.account-id=YOUR_ACCOUNT_ID
----

You can also change the interval at which metrics are sent to New Relic:

[source,properties,indent=0,configprops]
----
	management.metrics.export.newrelic.step=30s
----



[[production-ready-metrics-export-prometheus]]
==== Prometheus
{micrometer-registry-docs}/prometheus[Prometheus] expects to scrape or poll individual app instances for metrics.
Spring Boot provides an actuator endpoint available at `/actuator/prometheus` to present a https://prometheus.io[Prometheus scrape] with the appropriate format.

TIP: The endpoint is not available by default and must be exposed, see <<production-ready-endpoints-exposing-endpoints,exposing endpoints>> for more details.

Here is an example `scrape_config` to add to `prometheus.yml`:

[source,yaml,indent=0]
----
	scrape_configs:
	  - job_name: 'spring'
		metrics_path: '/actuator/prometheus'
		static_configs:
		  - targets: ['HOST:PORT']
----

For ephemeral or batch jobs which may not exist long enough to be scraped, https://github.com/prometheus/pushgateway[Prometheus Pushgateway] support can be used to expose their metrics to Prometheus.
To enable Prometheus Pushgateway support, add the following dependency to your project:

[source,xml,indent=0]
----
<dependency>
	<groupId>io.prometheus</groupId>
	<artifactId>simpleclient_pushgateway</artifactId>
</dependency>
----

When the Prometheus Pushgateway dependency is present on the classpath, Spring Boot auto-configures a `PrometheusPushGatewayManager` bean.
This manages the pushing of metrics to a Prometheus Pushgateway.
The `PrometheusPushGatewayManager` can be tuned using properties under `management.metrics.export.prometheus.pushgateway`.
For advanced configuration, you can also provide your own `PrometheusPushGatewayManager` bean.



[[production-ready-metrics-export-signalfx]]
==== SignalFx
SignalFx registry pushes metrics to {micrometer-registry-docs}/signalfx[SignalFx] periodically.
To export metrics to https://www.signalfx.com[SignalFx], your access token must be provided:

[source,properties,indent=0,configprops]
----
	management.metrics.export.signalfx.access-token=YOUR_ACCESS_TOKEN
----

You can also change the interval at which metrics are sent to SignalFx:

[source,properties,indent=0,configprops]
----
	management.metrics.export.signalfx.step=30s
----



[[production-ready-metrics-export-simple]]
==== Simple
Micrometer ships with a simple, in-memory backend that is automatically used as a fallback if no other registry is configured.
This allows you to see what metrics are collected in the <<production-ready-metrics-endpoint,metrics endpoint>>.

The in-memory backend disables itself as soon as you're using any of the other available backend.
You can also disable it explicitly:

[source,properties,indent=0,configprops]
----
	management.metrics.export.simple.enabled=false
----



[[production-ready-metrics-export-statsd]]
==== StatsD
The StatsD registry pushes metrics over UDP to a StatsD agent eagerly.
By default, metrics are exported to a {micrometer-registry-docs}/statsd[StatsD] agent running on your local machine.
The StatsD agent host and port to use can be provided using:

[source,properties,indent=0,configprops]
----
	management.metrics.export.statsd.host=statsd.example.com
	management.metrics.export.statsd.port=9125
----

You can also change the StatsD line protocol to use (default to Datadog):

[source,properties,indent=0,configprops]
----
	management.metrics.export.statsd.flavor=etsy
----



[[production-ready-metrics-export-wavefront]]
==== Wavefront
Wavefront registry pushes metrics to {micrometer-registry-docs}/wavefront[Wavefront] periodically.
If you are exporting metrics to https://www.wavefront.com/[Wavefront] directly, your API token must be provided:

[source,properties,indent=0,configprops]
----
	management.metrics.export.wavefront.api-token=YOUR_API_TOKEN
----

Alternatively, you may use a Wavefront sidecar or an internal proxy set up in your environment that forwards metrics data to the Wavefront API host:

[source,properties,indent=0,configprops]
----
	management.metrics.export.wavefront.uri=proxy://localhost:2878
----

TIP: If publishing metrics to a Wavefront proxy (as described in https://docs.wavefront.com/proxies_installing.html[the documentation]), the host must be in the `proxy://HOST:PORT` format.

You can also change the interval at which metrics are sent to Wavefront:

[source,properties,indent=0,configprops]
----
	management.metrics.export.wavefront.step=30s
----



[[production-ready-metrics-meter]]
=== Supported Metrics
Spring Boot registers the following core metrics when applicable:

* JVM metrics, report utilization of:
** Various memory and buffer pools
** Statistics related to garbage collection
** Threads utilization
** Number of classes loaded/unloaded
* CPU metrics
* File descriptor metrics
* Kafka consumer metrics
* Log4j2 metrics: record the number of events logged to Log4j2 at each level
* Logback metrics: record the number of events logged to Logback at each level
* Uptime metrics: report a gauge for uptime and a fixed gauge representing the application's absolute start time
* Tomcat metrics (`server.tomcat.mbeanregistry.enabled` must be set to `true` for all Tomcat metrics to be registered)
* {spring-integration-docs}system-management.html#micrometer-integration[Spring Integration] metrics



[[production-ready-metrics-spring-mvc]]
==== Spring MVC Metrics
Auto-configuration enables the instrumentation of requests handled by Spring MVC.
When `management.metrics.web.server.request.autotime.enabled` is `true`, this instrumentation occurs for all requests.
Alternatively, when set to `false`, you can enable instrumentation by adding `@Timed` to a request-handling method:

[source,java,indent=0]
----
	@RestController
	@Timed <1>
	public class MyController {

		@GetMapping("/api/people")
		@Timed(extraTags = { "region", "us-east-1" }) <2>
		@Timed(value = "all.people", longTask = true) <3>
		public List<Person> listPeople() { ... }

	}
----
<1> A controller class to enable timings on every request handler in the controller.
<2> A method to enable for an individual endpoint.
    This is not necessary if you have it on the class, but can be used to further customize the timer for this particular endpoint.
<3> A method with `longTask = true` to enable a long task timer for the method.
    Long task timers require a separate metric name, and can be stacked with a short task timer.

By default, metrics are generated with the name, `http.server.requests`.
The name can be customized by setting the configprop:management.metrics.web.server.request.metric-name[] property.

By default, Spring MVC-related metrics are tagged with the following information:

|===
| Tag | Description

| `exception`
| Simple class name of any exception that was thrown while handling the request.

| `method`
| Request's method (for example, `GET` or `POST`)

| `outcome`
| Request's outcome based on the status code of the response.
  1xx is `INFORMATIONAL`, 2xx is `SUCCESS`, 3xx is `REDIRECTION`, 4xx `CLIENT_ERROR`, and 5xx is `SERVER_ERROR`

| `status`
| Response's HTTP status code (for example, `200` or `500`)

| `uri`
| Request's URI template prior to variable substitution, if possible (for example, `/api/person/\{id}`)
|===

To customize the tags, provide a `@Bean` that implements `WebMvcTagsProvider`.



[[production-ready-metrics-web-flux]]
==== Spring WebFlux Metrics
Auto-configuration enables the instrumentation of all requests handled by WebFlux controllers and functional handlers.

By default, metrics are generated with the name `http.server.requests`.
You can customize the name by setting the configprop:management.metrics.web.server.request.metric-name[] property.

By default, WebFlux-related metrics are tagged with the following information:

|===
| Tag | Description

| `exception`
| Simple class name of any exception that was thrown while handling the request.

| `method`
| Request's method (for example, `GET` or `POST`)

| `outcome`
| Request's outcome based on the status code of the response.
  1xx is `INFORMATIONAL`, 2xx is `SUCCESS`, 3xx is `REDIRECTION`, 4xx `CLIENT_ERROR`, and 5xx is `SERVER_ERROR`

| `status`
| Response's HTTP status code (for example, `200` or `500`)

| `uri`
| Request's URI template prior to variable substitution, if possible (for example, `/api/person/\{id}`)
|===

To customize the tags, provide a `@Bean` that implements `WebFluxTagsProvider`.



[[production-ready-metrics-jersey-server]]
==== Jersey Server Metrics
When Micrometer's `micrometer-jersey2` module is on the classpath, auto-configuration enables the instrumentation of requests handled by the Jersey JAX-RS implementation.
When `management.metrics.web.server.request.autotime.enabled` is `true`, this instrumentation occurs for all requests.
Alternatively, when set to `false`, you can enable instrumentation by adding `@Timed` to a request-handling method:

[source,java,indent=0]
----
	@Component
	@Path("/api/people")
	@Timed <1>
	public class Endpoint {
		@GET
		@Timed(extraTags = { "region", "us-east-1" }) <2>
		@Timed(value = "all.people", longTask = true) <3>
		public List<Person> listPeople() { ... }
	}
----
<1> On a resource class to enable timings on every request handler in the resource.
<2> On a method to enable for an individual endpoint.
    This is not necessary if you have it on the class, but can be used to further customize the timer for this particular endpoint.
<3> On a method with `longTask = true` to enable a long task timer for the method.
    Long task timers require a separate metric name, and can be stacked with a short task timer.

By default, metrics are generated with the name, `http.server.requests`.
The name can be customized by setting the configprop:management.metrics.web.server.request.metric-name[] property.

By default, Jersey server metrics are tagged with the following information:

|===
| Tag | Description

| `exception`
| Simple class name of any exception that was thrown while handling the request.

| `method`
| Request's method (for example, `GET` or `POST`)

| `outcome`
| Request's outcome based on the status code of the response.
  1xx is `INFORMATIONAL`, 2xx is `SUCCESS`, 3xx is `REDIRECTION`, 4xx `CLIENT_ERROR`, and 5xx is `SERVER_ERROR`

| `status`
| Response's HTTP status code (for example, `200` or `500`)

| `uri`
| Request's URI template prior to variable substitution, if possible (for example, `/api/person/\{id}`)
|===

To customize the tags, provide a `@Bean` that implements `JerseyTagsProvider`.



[[production-ready-metrics-http-clients]]
==== HTTP Client Metrics
Spring Boot Actuator manages the instrumentation of both `RestTemplate` and `WebClient`.
For that, you have to get injected with an auto-configured builder and use it to create instances:

* `RestTemplateBuilder` for `RestTemplate`
* `WebClient.Builder` for `WebClient`

It is also possible to apply manually the customizers responsible for this instrumentation, namely `MetricsRestTemplateCustomizer` and `MetricsWebClientCustomizer`.

By default, metrics are generated with the name, `http.client.requests`.
The name can be customized by setting the configprop:management.metrics.web.client.request.metric-name[] property.

By default, metrics generated by an instrumented client are tagged with the following information:

|===
| Tag | Description

| `clientName`
| Host portion of the URI

| `method`
| Request's method (for example, `GET` or `POST`)

| `outcome`
| Request's outcome based on the status code of the response.
  1xx is `INFORMATIONAL`, 2xx is `SUCCESS`, 3xx is `REDIRECTION`, 4xx `CLIENT_ERROR`, and 5xx is `SERVER_ERROR`, `UNKNOWN` otherwise

| `status`
| Response's HTTP status code if available (for example, `200` or `500`), or `IO_ERROR` in case of I/O issues, `CLIENT_ERROR` otherwise

| `uri`
| Request's URI template prior to variable substitution, if possible (for example, `/api/person/\{id}`)
|===

To customize the tags, and depending on your choice of client, you can provide a `@Bean` that implements `RestTemplateExchangeTagsProvider` or `WebClientExchangeTagsProvider`.
There are convenience static functions in `RestTemplateExchangeTags` and `WebClientExchangeTags`.



[[production-ready-metrics-cache]]
==== Cache Metrics
Auto-configuration enables the instrumentation of all available ``Cache``s on startup with metrics prefixed with `cache`.
Cache instrumentation is standardized for a basic set of metrics.
Additional, cache-specific metrics are also available.

The following cache libraries are supported:

* Caffeine
* EhCache 2
* Hazelcast
* Any compliant JCache (JSR-107) implementation

Metrics are tagged by the name of the cache and by the name of the `CacheManager` that is derived from the bean name.

NOTE: Only caches that are available on startup are bound to the registry.
For caches created on-the-fly or programmatically after the startup phase, an explicit registration is required.
A `CacheMetricsRegistrar` bean is made available to make that process easier.



[[production-ready-metrics-jdbc]]
==== DataSource Metrics
Auto-configuration enables the instrumentation of all available `DataSource` objects with metrics prefixed with `jdbc.connections`.
Data source instrumentation results in gauges representing the currently active, idle, maximum allowed, and minimum allowed connections in the pool.

Metrics are also tagged by the name of the `DataSource` computed based on the bean name.

TIP: By default, Spring Boot provides metadata for all supported data sources; you can add additional `DataSourcePoolMetadataProvider` beans if your favorite data source isn't supported out of the box.
See `DataSourcePoolMetadataProvidersConfiguration` for examples.

Also, Hikari-specific metrics are exposed with a `hikaricp` prefix.
Each metric is tagged by the name of the Pool (can be controlled with `spring.datasource.name`).



[[production-ready-metrics-hibernate]]
==== Hibernate Metrics
Auto-configuration enables the instrumentation of all available Hibernate `EntityManagerFactory` instances that have statistics enabled with a metric named `hibernate`.

Metrics are also tagged by the name of the `EntityManagerFactory` that is derived from the bean name.

To enable statistics, the standard JPA property `hibernate.generate_statistics` must be set to `true`.
You can enable that on the auto-configured `EntityManagerFactory` as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.jpa.properties.hibernate.generate_statistics=true
----



[[production-ready-metrics-rabbitmq]]
==== RabbitMQ Metrics
Auto-configuration will enable the instrumentation of all available RabbitMQ connection factories with a metric named `rabbitmq`.



[[production-ready-metrics-custom]]
=== Registering custom metrics
To register custom metrics, inject `MeterRegistry` into your component, as shown in the following example:

[source,java,indent=0]
----
include::{code-examples}/actuate/metrics/MetricsMeterRegistryInjectionExample.java[tag=component]
----

If you find that you repeatedly instrument a suite of metrics across components or applications, you may encapsulate this suite in a `MeterBinder` implementation.
By default, metrics from all `MeterBinder` beans will be automatically bound to the Spring-managed `MeterRegistry`.



[[production-ready-metrics-per-meter-properties]]
=== Customizing individual metrics
If you need to apply customizations to specific `Meter` instances you can use the `io.micrometer.core.instrument.config.MeterFilter` interface.
By default, all `MeterFilter` beans will be automatically applied to the micrometer `MeterRegistry.Config`.

For example, if you want to rename the `mytag.region` tag to `mytag.area` for all meter IDs beginning with `com.example`, you can do the following:

[source,java,indent=0]
----
include::{code-examples}/actuate/metrics/MetricsFilterBeanExample.java[tag=configuration]
----



[[production-ready-metrics-common-tags]]
==== Common tags
Common tags are generally used for dimensional drill-down on the operating environment like host, instance, region, stack, etc.
Commons tags are applied to all meters and can be configured as shown in the following example:

[source,properties,indent=0,configprops]
----
	management.metrics.tags.region=us-east-1
	management.metrics.tags.stack=prod
----

The example above adds `region` and `stack` tags to all meters with a value of `us-east-1` and `prod` respectively.

NOTE: The order of common tags is important if you are using Graphite.
As the order of common tags cannot be guaranteed using this approach, Graphite users are advised to define a custom `MeterFilter` instead.



==== Per-meter properties
In addition to `MeterFilter` beans, it's also possible to apply a limited set of customization on a per-meter basis using properties.
Per-meter customizations apply to any all meter IDs that start with the given name.
For example, the following will disable any meters that have an ID starting with `example.remote`

[source,properties,indent=0,configprops]
----
	management.metrics.enable.example.remote=false
----

The following properties allow per-meter customization:

.Per-meter customizations
|===
| Property | Description

| configprop:management.metrics.enable[]
| Whether to deny meters from emitting any metrics.

| configprop:management.metrics.distribution.percentiles-histogram[]
| Whether to publish a histogram suitable for computing aggregable (across dimension) percentile approximations.

| configprop:management.metrics.distribution.minimum-expected-value[], configprop:management.metrics.distribution.maximum-expected-value[]
| Publish less histogram buckets by clamping the range of expected values.

| configprop:management.metrics.distribution.percentiles[]
| Publish percentile values computed in your application

| configprop:management.metrics.distribution.sla[]
| Publish a cumulative histogram with buckets defined by your SLAs.
|===

For more details on concepts behind `percentiles-histogram`, `percentiles` and `sla` refer to the {micrometer-concepts-docs}#_histograms_and_percentiles["Histograms and percentiles" section] of the micrometer documentation.



[[production-ready-metrics-endpoint]]
=== Metrics endpoint
Spring Boot provides a `metrics` endpoint that can be used diagnostically to examine the metrics collected by an application.
The endpoint is not available by default and must be exposed, see <<production-ready-endpoints-exposing-endpoints,exposing endpoints>> for more details.

Navigating to `/actuator/metrics` displays a list of available meter names.
You can drill down to view information about a particular meter by providing its name as a selector, e.g. `/actuator/metrics/jvm.memory.max`.

[TIP]
====
The name you use here should match the name used in the code, not the name after it has been naming-convention normalized for a monitoring system it is shipped to.
In other words, if `jvm.memory.max` appears as `jvm_memory_max` in Prometheus because of its snake case naming convention, you should still use `jvm.memory.max` as the selector when inspecting the meter in the `metrics` endpoint.
====

You can also add any number of `tag=KEY:VALUE` query parameters to the end of the URL to dimensionally drill down on a meter, e.g. `/actuator/metrics/jvm.memory.max?tag=area:nonheap`.

[TIP]
====
The reported measurements are the _sum_ of the statistics of all meters matching the meter name and any tags that have been applied.
So in the example above, the returned "Value" statistic is the sum of the maximum memory footprints of "Code Cache", "Compressed Class Space", and "Metaspace" areas of the heap.
If you just wanted to see the maximum size for the "Metaspace", you could add an additional `tag=id:Metaspace`, i.e. `/actuator/metrics/jvm.memory.max?tag=area:nonheap&tag=id:Metaspace`.
====



