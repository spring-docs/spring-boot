include::ROOT:partial$attributes.adoc[]
[[production-ready-endpoints]]
== Endpoints
Actuator endpoints let you monitor and interact with your application.
Spring Boot includes a number of built-in endpoints and lets you add your own.
For example, the `health` endpoint provides basic application health information.

Each individual endpoint can be <<production-ready-endpoints-enabling-endpoints, enabled or disabled>>.
This controls whether or not the endpoint is created and its bean exists in the application context.
To be remotely accessible an endpoint also has to be <<production-ready-endpoints-exposing-endpoints, exposed via JMX or HTTP>>.
Most applications choose HTTP, where the ID of the endpoint along with a prefix of `/actuator` is mapped to a URL.
For example, by default, the `health` endpoint is mapped to `/actuator/health`.

The following technology-agnostic endpoints are available:

[cols="2,5"]
|===
| ID | Description

| `auditevents`
| Exposes audit events information for the current application.
  Requires an `AuditEventRepository` bean.

| `beans`
| Displays a complete list of all the Spring beans in your application.

| `caches`
| Exposes available caches.

| `conditions`
| Shows the conditions that were evaluated on configuration and auto-configuration classes and the reasons why they did or did not match.

| `configprops`
| Displays a collated list of all `@ConfigurationProperties`.

| `env`
| Exposes properties from Spring's `ConfigurableEnvironment`.

| `flyway`
| Shows any Flyway database migrations that have been applied.
  Requires one or more `Flyway` beans.

| `health`
| Shows application health information.

| `httptrace`
| Displays HTTP trace information (by default, the last 100 HTTP request-response exchanges).
  Requires an `HttpTraceRepository` bean.

| `info`
| Displays arbitrary application info.

| `integrationgraph`
| Shows the Spring Integration graph.
  Requires a dependency on `spring-integration-core`.

| `loggers`
| Shows and modifies the configuration of loggers in the application.

| `liquibase`
| Shows any Liquibase database migrations that have been applied.
  Requires one or more `Liquibase` beans.

| `metrics`
| Shows '`metrics`' information for the current application.

| `mappings`
| Displays a collated list of all `@RequestMapping` paths.

| `scheduledtasks`
| Displays the scheduled tasks in your application.

| `sessions`
| Allows retrieval and deletion of user sessions from a Spring Session-backed session store.
  Requires a Servlet-based web application using Spring Session.

| `shutdown`
| Lets the application be gracefully shutdown.
  Disabled by default.

| `threaddump`
| Performs a thread dump.
|===

If your application is a web application (Spring MVC, Spring WebFlux, or Jersey), you can use the following additional endpoints:

[cols="2,5"]
|===
| ID | Description

| `heapdump`
| Returns an `hprof` heap dump file.

| `jolokia`
| Exposes JMX beans over HTTP (when Jolokia is on the classpath, not available for WebFlux).
  Requires a dependency on `jolokia-core`.

| `logfile`
| Returns the contents of the logfile (if `logging.file.name` or `logging.file.path` properties have been set).
  Supports the use of the HTTP `Range` header to retrieve part of the log file's content.

| `prometheus`
| Exposes metrics in a format that can be scraped by a Prometheus server.
  Requires a dependency on `micrometer-registry-prometheus`.
|===

To learn more about the Actuator's endpoints and their request and response formats, please refer to the separate API documentation ({spring-boot-actuator-restapi}/html/[HTML] or {spring-boot-actuator-restapi}/pdf/spring-boot-actuator-web-api.pdf[PDF]).



[[production-ready-endpoints-enabling-endpoints]]
=== Enabling Endpoints
By default, all endpoints except for `shutdown` are enabled.
To configure the enablement of an endpoint, use its `management.endpoint.<id>.enabled` property.
The following example enables the `shutdown` endpoint:

[source,properties,indent=0,configprops]
----
	management.endpoint.shutdown.enabled=true
----

If you prefer endpoint enablement to be opt-in rather than opt-out, set the configprop:management.endpoints.enabled-by-default[] property to `false` and use individual endpoint `enabled` properties to opt back in.
The following example enables the `info` endpoint and disables all other endpoints:

[source,properties,indent=0,configprops]
----
	management.endpoints.enabled-by-default=false
	management.endpoint.info.enabled=true
----

NOTE: Disabled endpoints are removed entirely from the application context.
If you want to change only the technologies over which an endpoint is exposed, use the <<production-ready-endpoints-exposing-endpoints, `include` and `exclude` properties>> instead.



[[production-ready-endpoints-exposing-endpoints]]
=== Exposing Endpoints
Since Endpoints may contain sensitive information, careful consideration should be given about when to expose them.
The following table shows the default exposure for the built-in endpoints:

[cols="1,1,1"]
|===
| ID | JMX | Web

| `auditevents`
| Yes
| No

| `beans`
| Yes
| No

| `caches`
| Yes
| No

| `conditions`
| Yes
| No

| `configprops`
| Yes
| No

| `env`
| Yes
| No

| `flyway`
| Yes
| No

| `health`
| Yes
| Yes

| `heapdump`
| N/A
| No

| `httptrace`
| Yes
| No

| `info`
| Yes
| Yes

| `integrationgraph`
| Yes
| No

| `jolokia`
| N/A
| No

| `logfile`
| N/A
| No

| `loggers`
| Yes
| No

| `liquibase`
| Yes
| No

| `metrics`
| Yes
| No

| `mappings`
| Yes
| No

| `prometheus`
| N/A
| No

| `scheduledtasks`
| Yes
| No

| `sessions`
| Yes
| No

| `shutdown`
| Yes
| No

| `threaddump`
| Yes
| No
|===

To change which endpoints are exposed, use the following technology-specific `include` and `exclude` properties:

[cols="3,1"]
|===
| Property | Default

| configprop:management.endpoints.jmx.exposure.exclude[]
|

| configprop:management.endpoints.jmx.exposure.include[]
| `*`

| configprop:management.endpoints.web.exposure.exclude[]
|

| configprop:management.endpoints.web.exposure.include[]
| `info, health`
|===

The `include` property lists the IDs of the endpoints that are exposed.
The `exclude` property lists the IDs of the endpoints that should not be exposed.
The `exclude` property takes precedence over the `include` property.
Both `include` and `exclude` properties can be configured with a list of endpoint IDs.

For example, to stop exposing all endpoints over JMX and only expose the `health` and `info` endpoints, use the following property:

[source,properties,indent=0,configprops]
----
	management.endpoints.jmx.exposure.include=health,info
----

`*` can be used to select all endpoints.
For example, to expose everything over HTTP except the `env` and `beans` endpoints, use the following properties:

[source,properties,indent=0,configprops]
----
	management.endpoints.web.exposure.include=*
	management.endpoints.web.exposure.exclude=env,beans
----

[NOTE]
====
`*` has a special meaning in YAML, so be sure to add quotes if you want to include (or exclude) all endpoints, as shown in the following example:

[source,yaml,indent=0]
----
	management:
	  endpoints:
	    web:
	      exposure:
	        include: "*"
----
====

NOTE: If your application is exposed publicly, we strongly recommend that you also <<production-ready-endpoints-security, secure your endpoints>>.

TIP: If you want to implement your own strategy for when endpoints are exposed, you can register an `EndpointFilter` bean.



[[production-ready-endpoints-security]]
=== Securing HTTP Endpoints
You should take care to secure HTTP endpoints in the same way that you would any other sensitive URL.
If Spring Security is present, endpoints are secured by default using Spring Securityâ€™s content-negotiation strategy.
If you wish to configure custom security for HTTP endpoints, for example, only allow users with a certain role to access them, Spring Boot provides some convenient `RequestMatcher` objects that can be used in combination with Spring Security.

A typical Spring Security configuration might look something like the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class ActuatorSecurity extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->
					requests.anyRequest().hasRole("ENDPOINT_ADMIN"));
			http.httpBasic();
		}

	}
----

The preceding example uses `EndpointRequest.toAnyEndpoint()` to match a request to any endpoint and then ensures that all have the `ENDPOINT_ADMIN` role.
Several other matcher methods are also available on `EndpointRequest`.
See the API documentation ({spring-boot-actuator-restapi}/html[HTML] or {spring-boot-actuator-restapi}/pdf/spring-boot-actuator-web-api.pdf[PDF]) for details.

If you deploy applications behind a firewall, you may prefer that all your actuator endpoints can be accessed without requiring authentication.
You can do so by changing the configprop:management.endpoints.web.exposure.include[] property, as follows:

.application.properties
[source,properties,indent=0,configprops]
----
	management.endpoints.web.exposure.include=*
----

Additionally, if Spring Security is present, you would need to add custom security configuration that allows unauthenticated access to the endpoints as shown in the following example:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class ActuatorSecurity extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) ->
				requests.anyRequest().permitAll());
		}

	}
----



[[production-ready-endpoints-caching]]
=== Configuring Endpoints
Endpoints automatically cache responses to read operations that do not take any parameters.
To configure the amount of time for which an endpoint will cache a response, use its `cache.time-to-live` property.
The following example sets the time-to-live of the `beans` endpoint's cache to 10 seconds:

.application.properties
[source,properties,indent=0,configprops]
----
	management.endpoint.beans.cache.time-to-live=10s
----

NOTE: The prefix `management.endpoint.<name>` is used to uniquely identify the endpoint that is being configured.

NOTE: When making an authenticated HTTP request, the `Principal` is considered as input to the endpoint and, therefore, the response will not be cached.



[[production-ready-endpoints-hypermedia]]
=== Hypermedia for Actuator Web Endpoints
A "`discovery page`" is added with links to all the endpoints.
The "`discovery page`" is available on `/actuator` by default.

When a custom management context path is configured, the "`discovery page`" automatically moves from `/actuator` to the root of the management context.
For example, if the management context path is `/management`, then the discovery page is available from `/management`.
When the management context path is set to `/`, the discovery page is disabled to prevent the possibility of a clash with other mappings.



[[production-ready-endpoints-cors]]
=== CORS Support
https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-origin resource sharing] (CORS) is a https://www.w3.org/TR/cors/[W3C specification] that lets you specify in a flexible way what kind of cross-domain requests are authorized.
If you use Spring MVC or Spring WebFlux, Actuator's web endpoints can be configured to support such scenarios.

CORS support is disabled by default and is only enabled once the configprop:management.endpoints.web.cors.allowed-origins[] property has been set.
The following configuration permits `GET` and `POST` calls from the `example.com` domain:

[source,properties,indent=0,configprops]
----
	management.endpoints.web.cors.allowed-origins=https://example.com
	management.endpoints.web.cors.allowed-methods=GET,POST
----

TIP: See {spring-boot-actuator-autoconfigure-module-code}/endpoint/web/CorsEndpointProperties.java[CorsEndpointProperties] for a complete list of options.



[[production-ready-endpoints-custom]]
=== Implementing Custom Endpoints
If you add a `@Bean` annotated with `@Endpoint`, any methods annotated with `@ReadOperation`, `@WriteOperation`, or `@DeleteOperation` are automatically exposed over JMX and, in a web application, over HTTP as well.
Endpoints can be exposed over HTTP using Jersey, Spring MVC, or Spring WebFlux.
If both Jersey and Spring MVC are available, Spring MVC will be used.

You can also write technology-specific endpoints by using `@JmxEndpoint` or `@WebEndpoint`.
These endpoints are restricted to their respective technologies.
For example, `@WebEndpoint` is exposed only over HTTP and not over JMX.

You can write technology-specific extensions by using `@EndpointWebExtension` and `@EndpointJmxExtension`.
These annotations let you provide technology-specific operations to augment an existing endpoint.

Finally, if you need access to web-framework-specific functionality, you can implement Servlet or Spring `@Controller` and `@RestController` endpoints at the cost of them not being available over JMX or when using a different web framework.



[[production-ready-endpoints-custom-input]]
==== Receiving Input
Operations on an endpoint receive input via their parameters.
When exposed via the web, the values for these parameters are taken from the URL's query parameters and from the JSON request body.
When exposed via JMX, the parameters are mapped to the parameters of the MBean's operations.
Parameters are required by default.
They can be made optional by annotating them with `@org.springframework.lang.Nullable`.

Each root property in the JSON request body can be mapped to a parameter of the endpoint.
Consider the following JSON request body:

[source,json,indent=0]
----
	{
		"name": "test",
		"counter": 42
	}
----

This can be used to invoke a write operation that takes `String name` and `int counter` parameters.

TIP: Because endpoints are technology agnostic, only simple types can be specified in the method signature.
In particular declaring a single parameter with a custom type defining a `name` and `counter` properties is not supported.

NOTE: To allow the input to be mapped to the operation method's parameters, Java code implementing an endpoint should be compiled with `-parameters`, and Kotlin code implementing an endpoint should be compiled with `-java-parameters`.
This will happen automatically if you are using Spring Boot's Gradle plugin or if you are using Maven and `spring-boot-starter-parent`.



[[production-ready-endpoints-custom-input-conversion]]
===== Input type conversion
The parameters passed to endpoint operation methods are, if necessary, automatically converted to the required type.
Before calling an operation method, the input received via JMX or an HTTP request is converted to the required types using an instance of `ApplicationConversionService` as well as any `Converter` or `GenericConverter` beans qualified with `@EndpointConverter`.



[[production-ready-endpoints-custom-web]]
==== Custom Web Endpoints
Operations on an `@Endpoint`, `@WebEndpoint`, or `@EndpointWebExtension` are automatically exposed over HTTP using Jersey, Spring MVC, or Spring WebFlux.
If both Jersey and Spring MVC are available, Spring MVC will be used.



[[production-ready-endpoints-custom-web-predicate]]
===== Web Endpoint Request Predicates
A request predicate is automatically generated for each operation on a web-exposed endpoint.



[[production-ready-endpoints-custom-web-predicate-path]]
===== Path
The path of the predicate is determined by the ID of the endpoint and the base path of web-exposed endpoints.
The default base path is `/actuator`.
For example, an endpoint with the ID `sessions` will use `/actuator/sessions` as its path in the predicate.

The path can be further customized by annotating one or more parameters of the operation method with `@Selector`.
Such a parameter is added to the path predicate as a path variable.
The variable's value is passed into the operation method when the endpoint operation is invoked.
If you want to capture all remaining path elements, you can add `@Selector(Match=ALL_REMAINING)` to the last parameter and make it a type that is conversion compatible with a `String[]`.



[[production-ready-endpoints-custom-web-predicate-http-method]]
===== HTTP method
The HTTP method of the predicate is determined by the operation type, as shown in the following table:

[cols="3, 1"]
|===
| Operation | HTTP method

| `@ReadOperation`
| `GET`

| `@WriteOperation`
| `POST`

| `@DeleteOperation`
| `DELETE`
|===



[[production-ready-endpoints-custom-web-predicate-consumes]]
===== Consumes
For a `@WriteOperation` (HTTP `POST`) that uses the request body, the consumes clause of the predicate is `application/vnd.spring-boot.actuator.v2+json, application/json`.
For all other operations the consumes clause is empty.



[[production-ready-endpoints-custom-web-predicate-produces]]
===== Produces
The produces clause of the predicate can be determined by the `produces` attribute of the `@DeleteOperation`, `@ReadOperation`, and `@WriteOperation` annotations.
The attribute is optional.
If it is not used, the produces clause is determined automatically.

If the operation method returns `void` or `Void` the produces clause is empty.
If the operation method returns a `org.springframework.core.io.Resource`, the produces clause is `application/octet-stream`.
For all other operations the produces clause is `application/vnd.spring-boot.actuator.v2+json, application/json`.



[[production-ready-endpoints-custom-web-response-status]]
===== Web Endpoint Response Status
The default response status for an endpoint operation depends on the operation type (read, write, or delete) and what, if anything, the operation returns.

A `@ReadOperation` returns a value, the response status will be 200 (OK).
If it does not return a value, the response status will be 404 (Not Found).

If a `@WriteOperation` or `@DeleteOperation` returns a value, the response status will be 200 (OK).
If it does not return a value the response status will be 204 (No Content).

If an operation is invoked without a required parameter, or with a parameter that cannot be converted to the required type, the operation method will not be called and the response status will be 400 (Bad Request).



[[production-ready-endpoints-custom-web-range-requests]]
===== Web Endpoint Range Requests
An HTTP range request can be used to request part of an HTTP resource.
When using Spring MVC or Spring Web Flux, operations that return a `org.springframework.core.io.Resource` automatically support range requests.

NOTE: Range requests are not supported when using Jersey.



[[production-ready-endpoints-custom-web-security]]
===== Web Endpoint Security
An operation on a web endpoint or a web-specific endpoint extension can receive the current `java.security.Principal` or `org.springframework.boot.actuate.endpoint.SecurityContext` as a method parameter.
The former is typically used in conjunction with `@Nullable` to provide different behavior for authenticated and unauthenticated users.
The latter is typically used to perform authorization checks using its `isUserInRole(String)` method.



[[production-ready-endpoints-custom-servlet]]
==== Servlet endpoints
A `Servlet` can be exposed as an endpoint by implementing a class annotated with `@ServletEndpoint` that also implements `Supplier<EndpointServlet>`.
Servlet endpoints provide deeper integration with the Servlet container but at the expense of portability.
They are intended to be used to expose an existing `Servlet` as an endpoint.
For new endpoints, the `@Endpoint` and `@WebEndpoint` annotations should be preferred whenever possible.



[[production-ready-endpoints-custom-controller]]
==== Controller endpoints
`@ControllerEndpoint` and `@RestControllerEndpoint` can be used to implement an endpoint that is only exposed by Spring MVC or Spring WebFlux.
Methods are mapped using the standard annotations for Spring MVC and Spring WebFlux such as `@RequestMapping` and `@GetMapping`, with the endpoint's ID being used as a prefix for the path.
Controller endpoints provide deeper integration with Spring's web frameworks but at the expense of portability.
The `@Endpoint` and `@WebEndpoint` annotations should be preferred whenever possible.



[[production-ready-health]]
=== Health Information
You can use health information to check the status of your running application.
It is often used by monitoring software to alert someone when a production system goes down.
The information exposed by the `health` endpoint depends on the configprop:management.endpoint.health.show-details[] and configprop:management.endpoint.health.show-components[] properties which can be configured with one of the following values:

[cols="1, 3"]
|===
| Name | Description

| `never`
| Details are never shown.

| `when-authorized`
| Details are only shown to authorized users.
  Authorized roles can be configured using `management.endpoint.health.roles`.

| `always`
| Details are shown to all users.
|===

The default value is `never`.
A user is considered to be authorized when they are in one or more of the endpoint's roles.
If the endpoint has no configured roles (the default) all authenticated users are considered to be authorized.
The roles can be configured using the configprop:management.endpoint.health.roles[] property.

NOTE: If you have secured your application and wish to use `always`, your security configuration must permit access to the health endpoint for both authenticated and unauthenticated users.

Health information is collected from the content of a {spring-boot-actuator-module-code}/health/HealthContributorRegistry.java[`HealthContributorRegistry`] (by default all {spring-boot-actuator-module-code}/health/HealthContributor.java[`HealthContributor`] instances defined in your `ApplicationContext`).
Spring Boot includes a number of auto-configured `HealthContributors` and you can also write your own.

A `HealthContributor` can either be a `HealthIndicator` or a `CompositeHealthContributor`.
A `HealthIndicator` provides actual health information, including a `Status`.
A `CompositeHealthContributor` provides a composite of other `HealthContributors`.
Taken together, contributors form a tree structure to represent the overall system health.

By default, the final system health is derived by a `StatusAggregator` which sorts the statuses from each `HealthIndicator` based on an ordered list of statuses.
The first status in the sorted list is used as the overall health status.
If no `HealthIndicator` returns a status that is known to the `StatusAggregator`, an `UNKNOWN` status is used.

TIP: The `HealthContributorRegistry` can be used to register and unregister health indicators at runtime.



==== Auto-configured HealthIndicators
The following `HealthIndicators` are auto-configured by Spring Boot when appropriate:

[cols="4,6"]
|===
| Name | Description

| {spring-boot-actuator-module-code}/cassandra/CassandraHealthIndicator.java[`CassandraHealthIndicator`]
| Checks that a Cassandra database is up.

| {spring-boot-actuator-module-code}/couchbase/CouchbaseHealthIndicator.java[`CouchbaseHealthIndicator`]
| Checks that a Couchbase cluster is up.

| {spring-boot-actuator-module-code}/system/DiskSpaceHealthIndicator.java[`DiskSpaceHealthIndicator`]
| Checks for low disk space.

| {spring-boot-actuator-module-code}/elasticsearch/ElasticSearchRestHealthContributorAutoConfiguration.java[`ElasticSearchRestHealthContributorAutoConfiguration`]
| Checks that an Elasticsearch cluster is up.

| {spring-boot-actuator-module-code}/hazelcast/HazelcastHealthIndicator.java[`HazelcastHealthIndicator`]
| Checks that a Hazelcast server is up.

| {spring-boot-actuator-module-code}/influx/InfluxDbHealthIndicator.java[`InfluxDbHealthIndicator`]
| Checks that an InfluxDB server is up.

| {spring-boot-actuator-module-code}/jms/JmsHealthIndicator.java[`JmsHealthIndicator`]
| Checks that a JMS broker is up.

| {spring-boot-actuator-module-code}/ldap/LdapHealthIndicator.java[`LdapHealthIndicator`]
| Checks that an LDAP server is up.

| {spring-boot-actuator-module-code}/mail/MailHealthIndicator.java[`MailHealthIndicator`]
| Checks that a mail server is up.

| {spring-boot-actuator-module-code}/mongo/MongoHealthIndicator.java[`MongoHealthIndicator`]
| Checks that a Mongo database is up.

| {spring-boot-actuator-module-code}/neo4j/Neo4jHealthIndicator.java[`Neo4jHealthIndicator`]
| Checks that a Neo4j database is up.

| {spring-boot-actuator-module-code}/health/PingHealthIndicator.java[`PingHealthIndicator`]
| Always responds with `UP`.

| {spring-boot-actuator-module-code}/amqp/RabbitHealthIndicator.java[`RabbitHealthIndicator`]
| Checks that a Rabbit server is up.

| {spring-boot-actuator-module-code}/redis/RedisHealthIndicator.java[`RedisHealthIndicator`]
| Checks that a Redis server is up.

| {spring-boot-actuator-module-code}/solr/SolrHealthIndicator.java[`SolrHealthIndicator`]
| Checks that a Solr server is up.
|===

TIP: You can disable them all by setting the configprop:management.health.defaults.enabled[] property.



==== Writing Custom HealthIndicators
To provide custom health information, you can register Spring beans that implement the {spring-boot-actuator-module-code}/health/HealthIndicator.java[`HealthIndicator`] interface.
You need to provide an implementation of the `health()` method and return a `Health` response.
The `Health` response should include a status and can optionally include additional details to be displayed.
The following code shows a sample `HealthIndicator` implementation:

[source,java,indent=0]
----
	import org.springframework.boot.actuate.health.Health;
	import org.springframework.boot.actuate.health.HealthIndicator;
	import org.springframework.stereotype.Component;

	@Component
	public class MyHealthIndicator implements HealthIndicator {

		@Override
		public Health health() {
			int errorCode = check(); // perform some specific health check
			if (errorCode != 0) {
				return Health.down().withDetail("Error Code", errorCode).build();
			}
			return Health.up().build();
		}

	}
----

NOTE: The identifier for a given `HealthIndicator` is the name of the bean without the `HealthIndicator` suffix, if it exists.
In the preceding example, the health information is available in an entry named `my`.

In addition to Spring Boot's predefined {spring-boot-actuator-module-code}/health/Status.java[`Status`] types, it is also possible for `Health` to return a custom `Status` that represents a new system state.
In such cases, a custom implementation of the {spring-boot-actuator-module-code}/health/StatusAggregator.java[`StatusAggregator`] interface also needs to be provided, or the default implementation has to be configured by using the configprop:management.endpoint.health.status.order[] configuration property.

For example, assume a new `Status` with code `FATAL` is being used in one of your `HealthIndicator` implementations.
To configure the severity order, add the following property to your application properties:

[source,properties,indent=0,configprops]
----
	management.endpoint.health.status.order=fatal,down,out-of-service,unknown,up
----

The HTTP status code in the response reflects the overall health status (for example, `UP` maps to 200, while `OUT_OF_SERVICE` and `DOWN` map to 503).
You might also want to register custom status mappings if you access the health endpoint over HTTP.
For example, the following property maps `FATAL` to 503 (service unavailable):

[source,properties,indent=0,configprops]
----
	management.endpoint.health.status.http-mapping.fatal=503
----

TIP: If you need more control, you can define your own `HttpCodeStatusMapper` bean.

The following table shows the default status mappings for the built-in statuses:

[cols="1,3"]
|===
| Status | Mapping

| DOWN
| SERVICE_UNAVAILABLE (503)

| OUT_OF_SERVICE
| SERVICE_UNAVAILABLE (503)

| UP
| No mapping by default, so http status is 200

| UNKNOWN
| No mapping by default, so http status is 200
|===



[[reactive-health-indicators]]
==== Reactive Health Indicators
For reactive applications, such as those using Spring WebFlux, `ReactiveHealthContributor` provides a non-blocking contract for getting application health.
Similar to a traditional `HealthContributor`, health information is collected from the content of a {spring-boot-actuator-module-code}/health/ReactiveHealthContributorRegistry.java[`ReactiveHealthContributorRegistry`] (by default all {spring-boot-actuator-module-code}/health/HealthContributor.java[`HealthContributor`] and {spring-boot-actuator-module-code}/health/ReactiveHealthContributor.java[`ReactiveHealthContributor`] instances defined in your `ApplicationContext`).
Regular `HealthContributors` that do not check against a reactive API are executed on the elastic scheduler.

TIP: In a reactive application, The `ReactiveHealthContributorRegistry` can be used to register and unregister health indicators at runtime.

To provide custom health information from a reactive API, you can register Spring beans that implement the {spring-boot-actuator-module-code}/health/ReactiveHealthIndicator.java[`ReactiveHealthIndicator`] interface.
The following code shows a sample `ReactiveHealthIndicator` implementation:

[source,java,indent=0]
----
	@Component
	public class MyReactiveHealthIndicator implements ReactiveHealthIndicator {

		@Override
		public Mono<Health> health() {
			return doHealthCheck() //perform some specific health check that returns a Mono<Health>
				.onErrorResume(ex -> Mono.just(new Health.Builder().down(ex).build()));
		}

	}
----

TIP: To handle the error automatically, consider extending from `AbstractReactiveHealthIndicator`.



==== Auto-configured ReactiveHealthIndicators
The following `ReactiveHealthIndicators` are auto-configured by Spring Boot when appropriate:

[cols="1,4"]
|===
| Name | Description

| {spring-boot-actuator-module-code}/cassandra/CassandraReactiveHealthIndicator.java[`CassandraReactiveHealthIndicator`]
| Checks that a Cassandra database is up.

| {spring-boot-actuator-module-code}/couchbase/CouchbaseReactiveHealthIndicator.java[`CouchbaseReactiveHealthIndicator`]
| Checks that a Couchbase cluster is up.

| {spring-boot-actuator-module-code}/mongo/MongoReactiveHealthIndicator.java[`MongoReactiveHealthIndicator`]
| Checks that a Mongo database is up.

| {spring-boot-actuator-module-code}/redis/RedisReactiveHealthIndicator.java[`RedisReactiveHealthIndicator`]
| Checks that a Redis server is up.
|===

TIP: If necessary, reactive indicators replace the regular ones.
Also, any `HealthIndicator` that is not handled explicitly is wrapped automatically.



==== Health Groups
It's sometimes useful to organize health indicators into groups that can be used for different purposes.
For example, if you deploy your application to Kubernetes, you may want one different sets of health indicators for your "`liveness`" and "`readiness`" probes.

To create a health indicator group you can use the `management.endpoint.health.group.<name>` property and specify a list of health indicator IDs to `include` or `exclude`.
For example, to create a group that includes only database indicators you can define the following:

[source,properties,indent=0,configprops]
----
	management.endpoint.health.group.custom.include=db
----

You can then check the result by hitting `http://localhost:8080/actuator/health/custom`.

By default groups will inherit the same `StatusAggregator` and `HttpCodeStatusMapper` settings as the system health, however, these can also be defined on a per-group basis.
It's also possible to override the `show-details` and `roles` properties if required:

[source,properties,indent=0,configprops]
----
	management.endpoint.health.group.custom.show-details=when-authorized
	management.endpoint.health.group.custom.roles=admin
	management.endpoint.health.group.custom.status.order=fatal,up
	management.endpoint.health.group.custom.status.http-mapping.fatal=500

----

TIP: You can use `@Qualifier("groupname")` if you need to register custom `StatusAggregator` or `HttpCodeStatusMapper` beans for use with the group.



[[production-ready-application-info]]
=== Application Information
Application information exposes various information collected from all {spring-boot-actuator-module-code}/info/InfoContributor.java[`InfoContributor`] beans defined in your `ApplicationContext`.
Spring Boot includes a number of auto-configured `InfoContributor` beans, and you can write your own.



[[production-ready-application-info-autoconfigure]]
==== Auto-configured InfoContributors
The following `InfoContributor` beans are auto-configured by Spring Boot, when appropriate:

[cols="1,4"]
|===
| Name | Description

| {spring-boot-actuator-module-code}/info/EnvironmentInfoContributor.java[`EnvironmentInfoContributor`]
| Exposes any key from the `Environment` under the `info` key.

| {spring-boot-actuator-module-code}/info/GitInfoContributor.java[`GitInfoContributor`]
| Exposes git information if a `git.properties` file is available.

| {spring-boot-actuator-module-code}/info/BuildInfoContributor.java[`BuildInfoContributor`]
| Exposes build information if a `META-INF/build-info.properties` file is available.
|===

TIP: It is possible to disable them all by setting the configprop:management.info.defaults.enabled[] property.



[[production-ready-application-info-env]]
==== Custom Application Information
You can customize the data exposed by the `info` endpoint by setting `+info.*+` Spring properties.
All `Environment` properties under the `info` key are automatically exposed.
For example, you could add the following settings to your `application.properties` file:

[source,properties,indent=0,configprops]
----
	info.app.encoding=UTF-8
	info.app.java.source=1.8
	info.app.java.target=1.8
----

[TIP]
====
Rather than hardcoding those values, you could also xref:howto:howto-properties-and-configuration:howto-automatic-expansion.adoc#howto-automatic-expansion[expand info properties at build time].

Assuming you use Maven, you could rewrite the preceding example as follows:

[source,properties,indent=0,configprops]
----
	info.app.encoding=@project.build.sourceEncoding@
	info.app.java.source=@java.version@
	info.app.java.target=@java.version@
----
====



[[production-ready-application-info-git]]
==== Git Commit Information
Another useful feature of the `info` endpoint is its ability to publish information about the state of your `git` source code repository when the project was built.
If a `GitProperties` bean is available, the `git.branch`, `git.commit.id`, and `git.commit.time` properties are exposed.

TIP: A `GitProperties` bean is auto-configured if a `git.properties` file is available at the root of the classpath.
See "xref:howto:howto-build:howto-git-info.adoc#howto-git-info[Generate git information]" for more details.

If you want to display the full git information (that is, the full content of `git.properties`), use the configprop:management.info.git.mode[] property, as follows:

[source,properties,indent=0,configprops]
----
	management.info.git.mode=full
----



[[production-ready-application-info-build]]
==== Build Information
If a `BuildProperties` bean is available, the `info` endpoint can also publish information about your build.
This happens if a `META-INF/build-info.properties` file is available in the classpath.

TIP: The Maven and Gradle plugins can both generate that file.
See "xref:howto:howto-build:howto-build-info.adoc#howto-build-info[Generate build information]" for more details.



[[production-ready-application-info-custom]]
==== Writing Custom InfoContributors
To provide custom application information, you can register Spring beans that implement the {spring-boot-actuator-module-code}/info/InfoContributor.java[`InfoContributor`] interface.

The following example contributes an `example` entry with a single value:

[source,java,indent=0]
----
	import java.util.Collections;

	import org.springframework.boot.actuate.info.Info;
	import org.springframework.boot.actuate.info.InfoContributor;
	import org.springframework.stereotype.Component;

	@Component
	public class ExampleInfoContributor implements InfoContributor {

		@Override
		public void contribute(Info.Builder builder) {
			builder.withDetail("example",
					Collections.singletonMap("key", "value"));
		}

	}
----

If you reach the `info` endpoint, you should see a response that contains the following additional entry:

[source,json,indent=0]
----
	{
		"example": {
			"key" : "value"
		}
	}
----



