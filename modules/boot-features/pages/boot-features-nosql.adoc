include::ROOT:partial$attributes.adoc[]
[[boot-features-nosql]]
== Working with NoSQL Technologies
Spring Data provides additional projects that help you access a variety of NoSQL technologies, including:

* {spring-data-mongodb}[MongoDB]
* {spring-data-neo4j}[Neo4J]
* {spring-data-elasticsearch}[Elasticsearch]
* {spring-data-solr}[Solr]
* {spring-data-redis}[Redis]
* {spring-data-gemfire}[GemFire] or {spring-data-geode}[Geode]
* {spring-data-cassandra}[Cassandra]
* {spring-data-couchbase}[Couchbase]
* {spring-data-ldap}[LDAP]

Spring Boot provides auto-configuration for Redis, MongoDB, Neo4j, Elasticsearch, Solr Cassandra, Couchbase, and LDAP.
You can make use of the other projects, but you must configure them yourself.
Refer to the appropriate reference documentation at {spring-data}.



[[boot-features-redis]]
=== Redis
https://redis.io/[Redis] is a cache, message broker, and richly-featured key-value store.
Spring Boot offers basic auto-configuration for the https://github.com/lettuce-io/lettuce-core/[Lettuce] and https://github.com/xetorthio/jedis/[Jedis] client libraries and the abstractions on top of them provided by https://github.com/spring-projects/spring-data-redis[Spring Data Redis].

There is a `spring-boot-starter-data-redis` "`Starter`" for collecting the dependencies in a convenient way.
By default, it uses https://github.com/lettuce-io/lettuce-core/[Lettuce].
That starter handles both traditional and reactive applications.

TIP: we also provide a `spring-boot-starter-data-redis-reactive` "`Starter`" for consistency with the other stores with reactive support.



[[boot-features-connecting-to-redis]]
==== Connecting to Redis
You can inject an auto-configured `RedisConnectionFactory`, `StringRedisTemplate`, or vanilla `RedisTemplate` instance as you would any other Spring Bean.
By default, the instance tries to connect to a Redis server at `localhost:6379`.
The following listing shows an example of such a bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private StringRedisTemplate template;

		@Autowired
		public MyBean(StringRedisTemplate template) {
			this.template = template;
		}

		// ...

	}
----

TIP: You can also register an arbitrary number of beans that implement `LettuceClientConfigurationBuilderCustomizer` for more advanced customizations.
If you use Jedis, `JedisClientConfigurationBuilderCustomizer` is also available.

If you add your own `@Bean` of any of the auto-configured types, it replaces the default (except in the case of `RedisTemplate`, when the exclusion is based on the bean name, `redisTemplate`, not its type).
By default, if `commons-pool2` is on the classpath, you get a pooled connection factory.



[[boot-features-mongodb]]
=== MongoDB
https://www.mongodb.com/[MongoDB] is an open-source NoSQL document database that uses a JSON-like schema instead of traditional table-based relational data.
Spring Boot offers several conveniences for working with MongoDB, including the `spring-boot-starter-data-mongodb` and `spring-boot-starter-data-mongodb-reactive` "`Starters`".



[[boot-features-connecting-to-mongodb]]
==== Connecting to a MongoDB Database
To access Mongo databases, you can inject an auto-configured `org.springframework.data.mongodb.MongoDbFactory`.
By default, the instance tries to connect to a MongoDB server at `mongodb://localhost/test`.
The following example shows how to connect to a MongoDB database:

[source,java,indent=0]
----
	import org.springframework.data.mongodb.MongoDbFactory;
	import com.mongodb.DB;

	@Component
	public class MyBean {

		private final MongoDbFactory mongo;

		@Autowired
		public MyBean(MongoDbFactory mongo) {
			this.mongo = mongo;
		}

		// ...

		public void example() {
			DB db = mongo.getDb();
			// ...
		}

	}
----

You can set the configprop:spring.data.mongodb.uri[] property to change the URL and configure additional settings such as the _replica set_, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test
----

Alternatively, as long as you use Mongo 2.x, you can specify a `host`/`port`.
For example, you might declare the following settings in your `application.properties`:

[source,properties,indent=0,configprops]
----
	spring.data.mongodb.host=mongoserver
	spring.data.mongodb.port=27017
----

If you have defined your own `MongoClient`, it will be used to auto-configure a suitable `MongoDbFactory`.
Both `com.mongodb.MongoClient` and `com.mongodb.client.MongoClient` are supported.

NOTE: If you use the Mongo 3.0 Java driver, `spring.data.mongodb.host` and `spring.data.mongodb.port` are not supported.
In such cases, `spring.data.mongodb.uri` should be used to provide all of the configuration.

TIP: If `spring.data.mongodb.port` is not specified, the default of `27017` is used.
You could delete this line from the example shown earlier.

TIP: If you do not use Spring Data Mongo, you can inject `com.mongodb.MongoClient` beans instead of using `MongoDbFactory`.
If you want to take complete control of establishing the MongoDB connection, you can also declare your own `MongoDbFactory` or `MongoClient` bean.

NOTE: If you are using the reactive driver, Netty is required for SSL.
The auto-configuration configures this factory automatically if Netty is available and the factory to use hasn't been customized already.



[[boot-features-mongo-template]]
==== MongoTemplate
{spring-data-mongodb}[Spring Data MongoDB] provides a {spring-data-mongodb-api}/core/MongoTemplate.html[`MongoTemplate`] class that is very similar in its design to Spring's `JdbcTemplate`.
As with `JdbcTemplate`, Spring Boot auto-configures a bean for you to inject the template, as follows:

[source,java,indent=0]
----
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.data.mongodb.core.MongoTemplate;
	import org.springframework.stereotype.Component;

	@Component
	public class MyBean {

		private final MongoTemplate mongoTemplate;

		@Autowired
		public MyBean(MongoTemplate mongoTemplate) {
			this.mongoTemplate = mongoTemplate;
		}

		// ...

	}
----

See the {spring-data-mongodb-api}/core/MongoOperations.html[`MongoOperations` Javadoc] for complete details.



[[boot-features-spring-data-mongo-repositories]]
[[boot-features-spring-data-mongodb-repositories]]
==== Spring Data MongoDB Repositories
Spring Data includes repository support for MongoDB.
As with the JPA repositories discussed earlier, the basic principle is that queries are constructed automatically, based on method names.

In fact, both Spring Data JPA and Spring Data MongoDB share the same common infrastructure.
You could take the JPA example from earlier and, assuming that `City` is now a Mongo data class rather than a JPA `@Entity`, it works in the same way, as shown in the following example:

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import org.springframework.data.domain.*;
	import org.springframework.data.repository.*;

	public interface CityRepository extends Repository<City, Long> {

		Page<City> findAll(Pageable pageable);

		City findByNameAndStateAllIgnoringCase(String name, String state);

	}
----

TIP: You can customize document scanning locations by using the `@EntityScan` annotation.

TIP: For complete details of Spring Data MongoDB, including its rich object mapping technologies, refer to its {spring-data-mongodb}[reference documentation].



[[boot-features-mongo-embedded]]
==== Embedded Mongo
Spring Boot offers auto-configuration for https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo[Embedded Mongo].
To use it in your Spring Boot application, add a dependency on `de.flapdoodle.embed:de.flapdoodle.embed.mongo`.

The port that Mongo listens on can be configured by setting the configprop:spring.data.mongodb.port[] property.
To use a randomly allocated free port, use a value of 0.
The `MongoClient` created by `MongoAutoConfiguration` is automatically configured to use the randomly allocated port.

NOTE: If you do not configure a custom port, the embedded support uses a random port (rather than 27017) by default.

If you have SLF4J on the classpath, the output produced by Mongo is automatically routed to a logger named `org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo`.

You can declare your own `IMongodConfig` and `IRuntimeConfig` beans to take control of the Mongo instance's configuration and logging routing.
The download configuration can be customized by declaring a `DownloadConfigBuilderCustomizer` bean.



[[boot-features-neo4j]]
=== Neo4j
https://neo4j.com/[Neo4j] is an open-source NoSQL graph database that uses a rich data model of nodes connected by first class relationships, which is better suited for connected big data than traditional RDBMS approaches.
Spring Boot offers several conveniences for working with Neo4j, including the `spring-boot-starter-data-neo4j` "`Starter`".



[[boot-features-connecting-to-neo4j]]
==== Connecting to a Neo4j Database
To access a Neo4j server, you can inject an auto-configured `org.neo4j.ogm.session.Session`.
By default, the instance tries to connect to a Neo4j server at `localhost:7687` using the Bolt protocol.
The following example shows how to inject a Neo4j `Session`:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final Session session;

		@Autowired
		public MyBean(Session session) {
			this.session = session;
		}

		// ...

	}
----

You can configure the uri and credentials to use by setting the `spring.data.neo4j.*` properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.uri=bolt://my-server:7687
	spring.data.neo4j.username=neo4j
	spring.data.neo4j.password=secret
----

You can take full control over the session creation by adding either an `org.neo4j.ogm.config.Configuration` bean or an `org.neo4j.ogm.session.SessionFactory` bean.



[[boot-features-connecting-to-neo4j-embedded]]
==== Using the Embedded Mode
If you add `org.neo4j:neo4j-ogm-embedded-driver` to the dependencies of your application, Spring Boot automatically configures an in-process embedded instance of Neo4j that does not persist any data when your application shuts down.

NOTE: As the embedded Neo4j OGM  driver  does not provide the Neo4j kernel itself, you have to declare `org.neo4j:neo4j` as dependency yourself.
Refer to https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started[the Neo4j OGM documentation] for a list of compatible versions.

The embedded driver takes precedence over the other drivers when there are multiple drivers on the classpath.
You can explicitly disable the embedded mode by setting `spring.data.neo4j.embedded.enabled=false`.

<<boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test,Data Neo4j Tests>> automatically make use of an embedded Neo4j instance if the embedded driver and Neo4j kernel are on the classpath as described above.

NOTE: You can enable persistence for the embedded mode by providing a path to a database file in your configuration, e.g. `spring.data.neo4j.uri=file://var/tmp/graph.db`.



[[boot-features-neo4j-ogm-native-types]]
==== Using Native Types
Neo4j-OGM can map some types, like those in `java.time.*`, to `String`-based properties or to one of the native types that Neo4j provides.
For backwards compatibility reasons the default for Neo4j-OGM is to use a `String`-based representation.
To use native types, add a dependency on either `org.neo4j:neo4j-ogm-bolt-native-types` or `org.neo4j:neo4j-ogm-embedded-native-types`, and configure the configprop:spring.data.neo4j.use-native-types[] property as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.use-native-types=true
----



[[boot-features-neo4j-ogm-session]]
==== Neo4jSession
By default, if you are running a web application, the session is bound to the thread for the entire processing of the request (that is, it uses the "Open Session in View" pattern).
If you do not want this behavior, add the following line to your `application.properties` file:

[source,properties,indent=0,configprops]
----
	spring.data.neo4j.open-in-view=false
----



[[boot-features-spring-data-neo4j-repositories]]
==== Spring Data Neo4j Repositories
Spring Data includes repository support for Neo4j.

Spring Data Neo4j shares the common infrastructure with Spring Data JPA as many other Spring Data modules do.
You could take the JPA example from earlier and define `City` as Neo4j OGM `@NodeEntity` rather than JPA `@Entity` and the repository abstraction works in the same way, as shown in the following example:

[source,java,indent=0]
----
	package com.example.myapp.domain;

	import java.util.Optional;

	import org.springframework.data.neo4j.repository.*;

	public interface CityRepository extends Neo4jRepository<City, Long> {

		Optional<City> findOneByNameAndState(String name, String state);

	}
----

The `spring-boot-starter-data-neo4j` "`Starter`" enables the repository support as well as transaction management.
You can customize the locations to look for repositories and entities by using `@EnableNeo4jRepositories` and `@EntityScan` respectively on a `@Configuration`-bean.

TIP: For complete details of Spring Data Neo4j, including its object mapping technologies, refer to the {spring-data-neo4j-docs}[reference documentation].



[[boot-features-solr]]
=== Solr
https://lucene.apache.org/solr/[Apache Solr] is a search engine.
Spring Boot offers basic auto-configuration for the Solr 5 client library and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-solr[Spring Data Solr].
There is a `spring-boot-starter-data-solr` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-solr]]
==== Connecting to Solr
You can inject an auto-configured `SolrClient` instance as you would any other Spring bean.
By default, the instance tries to connect to a server at `http://localhost:8983/solr`.
The following example shows how to inject a Solr bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private SolrClient solr;

		@Autowired
		public MyBean(SolrClient solr) {
			this.solr = solr;
		}

		// ...

	}
----

If you add your own `@Bean` of type `SolrClient`, it replaces the default.



[[boot-features-spring-data-solr-repositories]]
==== Spring Data Solr Repositories
Spring Data includes repository support for Apache Solr.
As with the JPA repositories discussed earlier, the basic principle is that queries are automatically constructed for you based on method names.

In fact, both Spring Data JPA and Spring Data Solr share the same common infrastructure.
You could take the JPA example from earlier and, assuming that `City` is now a `@SolrDocument` class rather than a JPA `@Entity`, it works in the same way.

IP: For complete details of Spring Data Solr, refer to the {spring-data-solr-docs}[reference documentation].



[[boot-features-elasticsearch]]
=== Elasticsearch
https://www.elastic.co/products/elasticsearch[Elasticsearch] is an open source, distributed, RESTful search and analytics engine.
Spring Boot offers basic auto-configuration for Elasticsearch.

Spring Boot supports several clients:

* The official Java "Low Level" and "High Level" REST clients
* The `ReactiveElasticsearchClient` provided by Spring Data Elasticsearch

The transport client is still available but its support has been deprecated in https://github.com/spring-projects/spring-data-elasticsearch[Spring Data Elasticsearch] and Elasticsearch itself.
It will be removed in a future release.
Spring Boot provides a dedicated "`Starter`", `spring-boot-starter-data-elasticsearch`.

The https://github.com/searchbox-io/Jest[Jest] client has been deprecated as well, since both Elasticsearch and Spring Data Elasticsearch provide official support for REST clients.



[[boot-features-connecting-to-elasticsearch-rest]]
==== Connecting to Elasticsearch using REST clients
Elasticsearch ships https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html[two different REST clients] that you can use to query a cluster: the "Low Level" client and the "High Level" client.

If you have the `org.elasticsearch.client:elasticsearch-rest-client` dependency on the classpath, Spring Boot will auto-configure and register a `RestClient` bean that by default targets `http://localhost:9200`.
You can further tune how `RestClient` is configured, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.rest.uris=https://search.example.com:9200
	spring.elasticsearch.rest.read-timeout=10s
	spring.elasticsearch.rest.username=user
	spring.elasticsearch.rest.password=secret
----

You can also register an arbitrary number of beans that implement `RestClientBuilderCustomizer` for more advanced customizations.
To take full control over the registration, define a `RestClient` bean.

If you have the `org.elasticsearch.client:elasticsearch-rest-high-level-client` dependency on the classpath, Spring Boot will auto-configure a `RestHighLevelClient`, which wraps any existing `RestClient` bean, reusing its HTTP configuration.


[[boot-features-connecting-to-elasticsearch-reactive-rest]]
==== Connecting to Elasticsearch using Reactive REST clients
{spring-data-elasticsearch}[Spring Data Elasticsearch] ships `ReactiveElasticsearchClient` for querying Elasticsearch instances in a reactive fashion.
It is built on top of WebFlux's `WebClient`, so both `spring-boot-starter-elasticsearch` and `spring-boot-starter-webflux` dependencies are useful to enable this support.

By default, Spring Boot will auto-configure and register a `ReactiveElasticsearchClient`
bean that targets `http://localhost:9200`.
You can further tune how it is configured, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
	spring.data.elasticsearch.client.reactive.use-ssl=true
	spring.data.elasticsearch.client.reactive.socket-timeout=10s
	spring.data.elasticsearch.client.reactive.username=user
	spring.data.elasticsearch.client.reactive.password=secret
----

If the configuration properties are not enough and you'd like to fully control the client
configuration, you can register a custom `ClientConfiguration` bean.

[[boot-features-connecting-to-elasticsearch-jest]]
==== Connecting to Elasticsearch using Jest
Now that Spring Boot supports the official `RestHighLevelClient`, Jest support is deprecated.

If you have `Jest` on the classpath, you can inject an auto-configured `JestClient` that by default targets `http://localhost:9200`.
You can further tune how the client is configured, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.elasticsearch.jest.uris=https://search.example.com:9200
	spring.elasticsearch.jest.read-timeout=10000
	spring.elasticsearch.jest.username=user
	spring.elasticsearch.jest.password=secret
----

You can also register an arbitrary number of beans that implement `HttpClientConfigBuilderCustomizer` for more advanced customizations.
The following example tunes additional HTTP settings:

[source,java,indent=0]
----
include::{code-examples}/elasticsearch/jest/JestClientCustomizationExample.java[tag=customizer]
----

To take full control over the registration, define a `JestClient` bean.



[[boot-features-connecting-to-elasticsearch-spring-data]]
==== Connecting to Elasticsearch by Using Spring Data
To connect to Elasticsearch, a `RestHighLevelClient` bean must be defined,
auto-configured by Spring Boot or manually provided by the application (see previous sections).
With this configuration in place, an
`ElasticsearchRestTemplate` can be injected like any other Spring bean,
as shown in the following example:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final ElasticsearchRestTemplate template;

		public MyBean(ElasticsearchRestTemplate template) {
			this.template = template;
		}

		// ...

	}
----

In the presence of `spring-data-elasticsearch` and the required dependencies for using a `WebClient` (typically `spring-boot-starter-webflux`), Spring Boot can also auto-configure a <<boot-features-connecting-to-elasticsearch-reactive-rest,ReactiveElasticsearchClient>> and a `ReactiveElasticsearchTemplate` as beans.
They are the reactive equivalent of the other REST clients.



[[boot-features-spring-data-elasticsearch-repositories]]
==== Spring Data Elasticsearch Repositories
Spring Data includes repository support for Elasticsearch.
As with the JPA repositories discussed earlier, the basic principle is that queries are constructed for you automatically based on method names.

In fact, both Spring Data JPA and Spring Data Elasticsearch share the same common infrastructure.
You could take the JPA example from earlier and, assuming that `City` is now an Elasticsearch `@Document` class rather than a JPA `@Entity`, it works in the same way.

TIP: For complete details of Spring Data Elasticsearch, refer to the {spring-data-elasticsearch-docs}[reference documentation].

Spring Boot supports both classic and reactive Elasticsearch repositories, using the `ElasticsearchRestTemplate` or `ReactiveElasticsearchTemplate` beans.
Most likely those beans are auto-configured by Spring Boot given the required dependencies are present.

If you wish to use your own template for backing the Elasticsearch repositories, you can add your own `ElasticsearchRestTemplate` or `ElasticsearchOperations` `@Bean`, as long as it is named `"elasticsearchTemplate"`.
Same applies to `ReactiveElasticsearchTemplate` and `ReactiveElasticsearchOperations`, with the bean name `"reactiveElasticsearchTemplate"`.

You can choose to disable the repositories support with the following property:

[source,properties,indent=0,configprops]
----
    spring.data.elasticsearch.repositories.enabled=false
----


[[boot-features-cassandra]]
=== Cassandra
https://cassandra.apache.org/[Cassandra] is an open source, distributed database management system designed to handle large amounts of data across many commodity servers.
Spring Boot offers auto-configuration for Cassandra and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-cassandra[Spring Data Cassandra].
There is a `spring-boot-starter-data-cassandra` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-cassandra]]
==== Connecting to Cassandra
You can inject an auto-configured `CassandraTemplate` or a Cassandra `Session` instance as you would with any other Spring Bean.
The `spring.data.cassandra.*` properties can be used to customize the connection.
Generally, you provide `keyspace-name` and `contact-points` properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.data.cassandra.keyspace-name=mykeyspace
	spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2
----

You can also register an arbitrary number of beans that implement `ClusterBuilderCustomizer` for more advanced customizations.

The following code listing shows how to inject a Cassandra bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private CassandraTemplate template;

		@Autowired
		public MyBean(CassandraTemplate template) {
			this.template = template;
		}

		// ...

	}
----

If you add your own `@Bean` of type `CassandraTemplate`, it replaces the default.



[[boot-features-spring-data-cassandra-repositories]]
==== Spring Data Cassandra Repositories
Spring Data includes basic repository support for Cassandra.
Currently, this is more limited than the JPA repositories discussed earlier and needs to annotate finder methods with `@Query`.

TIP: For complete details of Spring Data Cassandra, refer to the https://docs.spring.io/spring-data/cassandra/docs/[reference documentation].



[[boot-features-couchbase]]
=== Couchbase
https://www.couchbase.com/[Couchbase] is an open-source, distributed, multi-model NoSQL document-oriented database that is optimized for interactive applications.
Spring Boot offers auto-configuration for Couchbase and the abstractions on top of it provided by https://github.com/spring-projects/spring-data-couchbase[Spring Data Couchbase].
There are `spring-boot-starter-data-couchbase` and `spring-boot-starter-data-couchbase-reactive` "`Starters`" for collecting the dependencies in a convenient way.



[[boot-features-connecting-to-couchbase]]
==== Connecting to Couchbase
You can get a `Bucket` and `Cluster` by adding the Couchbase SDK and some configuration.
The `spring.couchbase.*` properties can be used to customize the connection.
Generally, you provide the bootstrap hosts, bucket name, and password, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
	spring.couchbase.bucket.name=my-bucket
	spring.couchbase.bucket.password=secret
----

TIP: You need to provide _at least_ the bootstrap host(s), in which case the bucket name is `default` and the password is an empty String.
Alternatively, you can define your own `org.springframework.data.couchbase.config.CouchbaseConfigurer` `@Bean` to take control over the whole configuration.

It is also possible to customize some of the `CouchbaseEnvironment` settings.
For instance, the following configuration changes the timeout to use to open a new `Bucket` and enables SSL support:

[source,properties,indent=0,configprops]
----
	spring.couchbase.env.timeouts.connect=3000
	spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
	spring.couchbase.env.ssl.key-store-password=secret
----

Check the `spring.couchbase.env.*` properties for more details.



[[boot-features-spring-data-couchbase-repositories]]
==== Spring Data Couchbase Repositories
Spring Data includes repository support for Couchbase.
For complete details of Spring Data Couchbase, refer to the https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/[reference documentation].

You can inject an auto-configured `CouchbaseTemplate` instance as you would with any other Spring Bean, provided a _default_ `CouchbaseConfigurer` is available (which happens when you enable Couchbase support, as explained earlier).

The following examples shows how to inject a Couchbase bean:

[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final CouchbaseTemplate template;

		@Autowired
		public MyBean(CouchbaseTemplate template) {
			this.template = template;
		}

		// ...

	}
----

There are a few beans that you can define in your own configuration to override those provided by the auto-configuration:

* A `CouchbaseTemplate` `@Bean` with a name of `couchbaseTemplate`.
* An `IndexManager` `@Bean` with a name of `couchbaseIndexManager`.
* A `CustomConversions` `@Bean` with a name of `couchbaseCustomConversions`.

To avoid hard-coding those names in your own config, you can reuse `BeanNames` provided by Spring Data Couchbase.
For instance, you can customize the converters to use, as follows:

[source,java,indent=0]
----
	@Configuration(proxyBeanMethods = false)
	public class SomeConfiguration {

		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
		public CustomConversions myCustomConversions() {
			return new CustomConversions(...);
		}

		// ...

	}
----

TIP: If you want to fully bypass the auto-configuration for Spring Data Couchbase, provide your own implementation of `org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration`.



[[boot-features-ldap]]
=== LDAP
https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[LDAP] (Lightweight Directory Access Protocol) is an open, vendor-neutral, industry standard application protocol for accessing and maintaining distributed directory information services over an IP network.
Spring Boot offers auto-configuration for any compliant LDAP server as well as support for the embedded in-memory LDAP server from https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID].

LDAP abstractions are provided by https://github.com/spring-projects/spring-data-ldap[Spring Data LDAP].
There is a `spring-boot-starter-data-ldap` "`Starter`" for collecting the dependencies in a convenient way.



[[boot-features-ldap-connecting]]
==== Connecting to an LDAP Server
To connect to an LDAP server, make sure you declare a dependency on the `spring-boot-starter-data-ldap` "`Starter`" or `spring-ldap-core` and then declare the URLs of your server in your application.properties, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.ldap.urls=ldap://myserver:1235
	spring.ldap.username=admin
	spring.ldap.password=secret
----

If you need to customize connection settings, you can use the `spring.ldap.base` and `spring.ldap.base-environment` properties.

An `LdapContextSource` is auto-configured based on these settings.
If you need to customize it, for instance to use a `PooledContextSource`, you can still inject the auto-configured `LdapContextSource`.
Make sure to flag your customized `ContextSource` as `@Primary` so that the auto-configured `LdapTemplate` uses it.



[[boot-features-ldap-spring-data-repositories]]
==== Spring Data LDAP Repositories
Spring Data includes repository support for LDAP.
For complete details of Spring Data LDAP, refer to the https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/[reference documentation].

You can also inject an auto-configured `LdapTemplate` instance as you would with any other Spring Bean, as shown in the following example:


[source,java,indent=0]
----
	@Component
	public class MyBean {

		private final LdapTemplate template;

		@Autowired
		public MyBean(LdapTemplate template) {
			this.template = template;
		}

		// ...

	}
----



[[boot-features-ldap-embedded]]
==== Embedded In-memory LDAP Server
For testing purposes, Spring Boot supports auto-configuration of an in-memory LDAP server from https://www.ldap.com/unboundid-ldap-sdk-for-java[UnboundID].
To configure the server, add a dependency to `com.unboundid:unboundid-ldapsdk` and declare a configprop:spring.ldap.embedded.base-dn[] property, as follows:

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn=dc=spring,dc=io
----

[NOTE]
====
It is possible to define multiple base-dn values, however, since distinguished names usually contain commas, they must be defined using the correct notation.

In yaml files, you can use the yaml list notation:

[source,yaml,indent=0]
----
	spring.ldap.embedded.base-dn:
	  - dc=spring,dc=io
	  - dc=pivotal,dc=io
----

In properties files, you must include the index as part of the property name:

[source,properties,indent=0,configprops]
----
	spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
	spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io
----

====

By default, the server starts on a random port and triggers the regular LDAP support.
There is no need to specify a configprop:spring.ldap.urls[] property.

If there is a `schema.ldif` file on your classpath, it is used to initialize the server.
If you want to load the initialization script from a different resource, you can also use the configprop:spring.ldap.embedded.ldif[] property.

By default, a standard schema is used to validate `LDIF` files.
You can turn off validation altogether by setting the configprop:spring.ldap.embedded.validation.enabled[] property.
If you have custom attributes, you can use configprop:spring.ldap.embedded.validation.schema[] to define your custom attribute types or object classes.



[[boot-features-influxdb]]
=== InfluxDB
https://www.influxdata.com/[InfluxDB] is an open-source time series database optimized for fast, high-availability storage and retrieval of time series data in fields such as operations monitoring, application metrics, Internet-of-Things sensor data, and real-time analytics.



[[boot-features-connecting-to-influxdb]]
==== Connecting to InfluxDB
Spring Boot auto-configures an `InfluxDB` instance, provided the `influxdb-java` client is on the classpath and the URL of the database is set, as shown in the following example:

[source,properties,indent=0,configprops]
----
	spring.influx.url=https://172.0.0.1:8086
----

If the connection to InfluxDB requires a user and password, you can set the `spring.influx.user` and `spring.influx.password` properties accordingly.

InfluxDB relies on OkHttp.
If you need to tune the http client `InfluxDB` uses behind the scenes, you can register an `InfluxDbOkHttpClientBuilderProvider` bean.



